# -*- coding: utf-8 -*-
"""lab1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xs1Y2y-3187p0CN9DsxpgQs0zDrCgjdW

# Exercício 1-A
"""

import numpy as np
import matplotlib.pyplot as plt

def gerar_bernoulli(p):
 u = np.random.uniform(0,1)
 if u<= p:
  return 1
 else:
  return 0


amostra = [gerar_bernoulli(0.3) for _ in range(100)]

plt.hist(amostra)

"""# Exercício 1-B"""

m = int(input())
B = [gerar_bernoulli(0.5) for i in range(m)]
print(B)

amostra_uniforme = []
M=int(input())
for j in range(M):
  B = [gerar_bernoulli(0.5) for i in range(m)]
  soma = 0
  for i in range(1,m):
    soma  += (1/2**(i))*B[i]
  amostra_uniforme.append(soma)

print(amostra_uniforme)


amostra_uniforme2 = np.random.uniform(low = 0, high = 1,size = 1000)

plt.hist(amostra_uniforme)

plt.hist(amostra_uniforme2)

"""# Exercício 2-A"""

import time
def gerar_bernoulli(p):
 u = np.random.uniform(0,1)
 if u<= p:
  return 1
 else:
  return 0

def gerar_binomial_ingenua(n,p):
  return sum([gerar_bernoulli(p) for j in range(n)])

amostra_binomial_ingenua = [gerar_binomial_ingenua(1000,0.01) for _ in range(1000)]


print(amostra_binomial_ingenua)


start1 = time.time()
def gerar_bernoulli(p):
 u = np.random.uniform(0,1)
 if u<= p:
  return 1
 else:
  return 0

def gerar_binomial_ingenua(n,p):
  return sum([gerar_bernoulli(p) for j in range(n)])

amostra_binomial_ingenua = [gerar_binomial_ingenua(20,0.1) for _ in range(100000)]
end1 = time.time()
print("Tempo:", end1 - start1)


start2 = time.time()
def gerar_bernoulli(p):
 u = np.random.uniform(0,1)
 if u<= p:
  return 1
 else:
  return 0

def gerar_binomial_ingenua(n,p):
  return sum([gerar_bernoulli(p) for j in range(n)])

amostra_binomial_ingenua = [gerar_binomial_ingenua(20,0.5) for _ in range(100000)]
end2 = time.time()
print("Tempo:", end2 - start2)

start3 = time.time()
def gerar_bernoulli(p):
 u = np.random.uniform(0,1)
 if u<= p:
  return 1
 else:
  return 0

def gerar_binomial_ingenua(n,p):
  return sum([gerar_bernoulli(p) for j in range(n)])

amostra_binomial_ingenua = [gerar_binomial_ingenua(20,0.9) for _ in range(100000)]
end3 = time.time()
print("Tempo:", end3 - start3)
plt.hist(amostra_binomial_ingenua,density=True)

import time
start4 = time.time()
def gerar_binomial_recursiva(n,p):
  u = np.random.uniform(0,1)
  i = 0
  pi = (1-p)**n
  F = pi
  while u > F:
      pi = pi*((n-i)/(i+1))*(p/(1-p))
      i = i+ 1
      F = F + pi

  return i

amostra_binomial_recursiva = [gerar_binomial_recursiva(20,0.1) for _ in range(100)]
print(amostra_binomial_recursiva)
end4 = time.time()
print("Tempo:",end4 - start4)
plt.hist(amostra_binomial_recursiva,density=True)

from pickle import TRUE
plt.hist(np.random.binomial(n=20,p=0.1,size=100),density=True)

start5 = time.time()
def gerar_binomial_recursiva(n,p):
  u = np.random.uniform(0,1)
  i = 0
  pi = (1-p)**n
  F = pi
  while u > F:
      pi = pi*((n-i)/(i+1))*(p/(1-p))
      i = i+ 1
      F = F + pi
  return i

amostra_binomial_recursiva_2 = [gerar_binomial_recursiva(20,0.5) for _ in range(100)]


end5 = time.time()
print("Tempo:", end5 - start5)


start6 = time.time()
def gerar_binomial_recursiva(n,p):
  u = np.random.uniform(0,1)
  i = 0
  pi = (1-p)**n
  F = pi
  while u > F:
      pi = pi*((n-i)/(i+1))*(p/(1-p))
      i = i+ 1
      F = F + pi
  return i

amostra_binomial_recursiva_3 = [gerar_binomial_recursiva(20,0.5) for _ in range(100)]


end6 = time.time()
print("Tempo:", end6 - start6)

numero_medio_passos = 1 + 20*(0.1)
print(numero_medio_passos)
numero_medio_passos2 = 1 + 20*(0.5)
print(numero_medio_passos2)
numero_medio_passos3 = 1+ 20*(0.9)
print(numero_medio_passos3)