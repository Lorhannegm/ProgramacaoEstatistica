# -*- coding: utf-8 -*-
"""lab2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cd9jjNYHTxPVcusfXABavw9srfntd6hS

# Exercício 2
"""

import numpy as np
import math
import time
import matplotlib.pyplot as plt

#Versão recursiva geométrica
def geometrica_recursiva(p):
  u = np.random.uniform(0,1)
  x = math.floor((np.log(1-u)/np.log(1-p))) + 1
  return x

amostra1 = [geometrica_recursiva(0.2) for _ in range(100000)]
print(amostra1)

def gerar_bernoulli ( p ):
 u = np.random.uniform( 0 , 1 )
 if  u<= p:
  return 1
 else :
   return 0





def gerar_geometrica_ingenua(p):
  i = 0
  b = gerar_bernoulli(p)
  while b == 0:
    i = i + 1
    b = gerar_bernoulli(p)
  return i



amostra_geometrica_ingenua = [gerar_geometrica_ingenua(0.2)for l in range(10000)]
print(amostra_geometrica_ingenua)

#tempo geométrica inversão
start = time.time()
def geometrica_recursiva(p):
  u = np.random.uniform(0,1)
  x = math.floor((np.log(1-u)/np.log(1-p))) + 1
  return x
amostra1 = [geometrica_recursiva(0.2) for _ in range(100000)]
print(amostra1)
end = time.time()
print("Tempo:", end - start)

#tempo geométrica ingênua
start2 = time.time()


def gerar_geometrica_ingenua(p):
  i = 0
  b = gerar_bernoulli(p)
  while b == 0:
    i = i + 1
    b = gerar_bernoulli(p)
  return i

amostra_geometrica_ingenua = [gerar_geometrica_ingenua(0.2)for l in range(10000)]
print(amostra_geometrica_ingenua)
end2 = time.time()
print("Tempo:",end2 -start2)

numpy.random.geometric()

"""# Exercício 1"""

import numpy as np
import matplotlib.pyplot as plt
def poisson_recursiva(lam):
  p = np.exp(-lam)
  F = p
  i = 0
  u = np.random.uniform(0,1)
  while u > F:
    i = i+1
    p = p*(lam/i)
    F = F+p
  return i

amostra1_possion_recursiva = [poisson_recursiva(1) for _ in range(100000)]
print(amostra1_possion_recursiva)

amostra2_possion_recursiva = [poisson_recursiva(5) for _ in range(100000)]
print(amostra2_possion_recursiva)

amostra3_possion_recursiva = [poisson_recursiva(10) for _ in range(100000)]
print(amostra3_possion_recursiva)

amostra4_possion_recursiva = [poisson_recursiva(50) for _ in range(100000)]
print(amostra4_possion_recursiva)

amostra5_possion_recursiva = [poisson_recursiva(100) for _ in range(100000)]
print(amostra5_possion_recursiva)

#2
m = 1000

def gerar_bernoulli(p):
 u = np.random.uniform(0,1)
 if u<= p:
  return 1
 else:
  return 0

def gerar_binomial(n,p):
  return sum([gerar_bernoulli(p) for j in range(n)])

amostra_binomial = [gerar_binomial(1000,0.01) for _ in range(1000)]


print(amostra_binomial)

plt.hist(amostra_binomial)

amostra6_possion_recursiva = [poisson_recursiva(10) for _ in range(100000)]
print(amostra6_possion_recursiva)
plt.hist(amostra6_possion_recursiva)

import numpy as np
import math
#Versão recursiva geométrica
def geometrica_recursiva(p):
  u = np.random.uniform(0,1)
  x = np.floor((np.log(1-u)/np.log(1-p))) + 1
  return x

amostra1 = [geometrica_recursiva(0.2) for _ in range(100000)]
print(amostra1)

"""# Exercício 3

Exercício3
"""

def bin_neg_soma_geo(r,p):
  return sum([geometrica_recursiva(p) for g in range(r)])

def bin_neg_ber(r,p):
  n = 0
  s = 0
  while r > s:
    B = gerar_bernoulli(p)
    n = n + 1
    if B == 1:
      s = s +1
  return n

def bin_neg_recursiva(r,p):
  u = np.random.uniform(0,1)
  n = r
  pn = p**r
  F = pn
  while u > F:
    pn = pn*(1-p)*(n/(n-r+1))
    n = n + 1
    F = F + pn
  return n

amostra_bin_1 = [bin_neg_soma_geo(5,0.3) for k in range(100000)]
print(amostra_bin_1)
amostra_bin_neg_2 = [bin_neg_ber(5,0.3) for _ in range(100000)]
print(amostra_bin_neg_2)
amostra_bin_neg_3 = [ bin_neg_recursiva(5,0.3) for _ in range(100000)]
print(amostra_bin_neg_3)

bin_neg_np = np.random.negative_binomial(5, 0.3,100000)
print(bin_neg_np)

plt.hist(amostra_bin_1)

plt.hist(amostra_bin_neg_2)

plt.hist(amostra_bin_neg_3)

plt.hist(bin_neg_np)

start3 = time.time()
amostra_teste_1 = [bin_neg_soma_geo(5,0.1) for i in range(100000)]
print(amostra_teste_1)
end3 = time.time()
print("Tempo:",end3 -start3)

start4 = time.time()
amostra_teste_2 = [bin_neg_soma_geo(5,0.9)for i in range(100000)]
print(amostra_teste_2)
end3 = time.time()
print("Tempo:",end3 -start3)
start5 = time.time()
amostra_teste_3 = [bin_neg_soma_geo(20,0.9)for i in range(100000)]
print("amostra_teste_3")
end5 = time.time()
print("Tempo:",end5 -start5)

start6 = time.time()
amostra_teste_4 = [bin_neg_ber(20,0.9)for i in range(100000)]
print(amostra_teste_4)
end6 = time.time()
print("Tempo:",end6 -start6)

start7 = time.time()
amostra_teste_5 = [bin_neg_ber(5,0.1)for i in range(100000)]
print(amostra_teste_5)
end7 = time.time()
print("Tempo:",end7 -start7)

start8 = time.time()
amostra_teste_6 = [bin_neg_ber(5,0.9)for i in range(100000)]
print(amostra_teste_6)
end8 = time.time()
print("Tempo:",end8-start8)

start9 = time.time()
amostra_teste_7 = [bin_neg_recursiva(5,0.1)for i in range(100000)]
print(amostra_teste_7)
end9 = time.time()
print("Tempo:",end9-start9)

start10 = time.time()
amostra_teste_8 =  [bin_neg_recursiva(20,0.9)for i in range(100000)]
print(amostra_teste_8)
end10 = time.time()
print("Tempo:",end10-start10)

start11 = time.time()
amostra_teste_9 =  [bin_neg_recursiva(5,0.9)for i in range(100000)]
print(amostra_teste_9)
end11 = time.time()
print("Tempo:",end11-start11)
#Dos 3 métodos podemos perceber que o que vai mais rápido é o recursivo,já para a soma dr geométricas o que demorou mais foi o que tinha maaior r e maior p e na quando fizemos pela bernoulli foi o que tinha menor r e menor p que demorou mais,no geral percebemos que é mais rápido o método recursivo

"""# Exercício 4"""

import random
def hipergeometrica(populacao,n):
  numero_aleatorio=random.randint(1, n)