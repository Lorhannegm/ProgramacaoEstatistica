# -*- coding: utf-8 -*-
"""lab4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rO5L2roVJDCIGEy5w0KkW53hpegcm4nE

# Exercício 1
"""

#a)
import numpy as np
import matplotlib.pyplot as plt
def exponencial(lam):
  u = np.random.uniform(0,1)
  x = -np.log(1-u)/lam
  return x
def normal_posi():
  Y = exponencial(1)
  u = np.random.uniform(0.1)
  while u >= np.exp(-(Y-1)/2):
    Y = exponencial(1)
    u = np.random.uniform(0,1)
  return Y


print(normal_posi())

#b)
def gerar_bernoulli ( p ):
 u = np.random.uniform( 0 , 1 )
 if  u<= p:
  return 1
 else :
   return 0

def normal_padrao():
  Y = exponencial(1)
  u = np.random.uniform(0.1)
  B = gerar_bernoulli(0.5)
  while u >= np.exp(-(Y-1)/2):
    Y = exponencial(1)
    u = np.random.uniform(0,1)
  if B == 1:
    return Y
  else:
    return -Y
print(normal_padrao())


amostra_1 = [normal_padrao() for _ in range(10000)]
print(amostra_1)
plt.hist(amostra_1)
plt.show()

amostra_2 = np.random.normal(0,1,10000)
plt.hist(amostra_2)
plt.show()

def normal(mu,sigma2):
  Y = exponencial(1)
  u = np.random.uniform(0.1)
  B = gerar_bernoulli(0.5)
  sigma = np.sqrt(sigma2)
  while u >= np.exp(-(Y-1)/2):
    Y = exponencial(1)
    u = np.random.uniform(0,1)
  if B == 1:
    return (sigma*Y) + mu
  else:
    return (sigma*(-Y)) + mu


amostra_1 = [normal(1,16) for _ in range(100000)]
plt.hist(amostra_1)
plt.show()

amostra2 = np.random.normal(1,4, size=100000)
plt.hist(amostra2)
plt.show

"""# Exercício 2

Primeira parte da questão:
Uuma g(x) seria Uniform(0,pi),como c >= f(s)/g(s) -> c >= ((1/2)*sin(x))/(1/pi), assim para encontrar o máximo faremos f'(x)*pi = 0 -> (1/2)*cos(s) = 0 ->s = arco cosseno(0) -> pi/2,assim o máximo ocorre em pi * f(pi/2)= (1/2)*sin(1/2)*pi-> (1/2)*1*pi = pi/2 -> c = pi/2
"""

def amost_rej():
  u = np.random.uniform(0,1)
  Y = np.random.uniform(0,np.pi)
  while u > np.sin(Y):
    u = np.random.uniform(0,1)
    Y = np.random.uniform(0,np.pi)
  return Y*(np.pi)
print(amost_rej)
def amost_rej_med():
  contador = 0
  u = np.random.uniform(0,1)
  Y = np.random.uniform(0,np.pi)
  quo = -1
  while u > quo:
    contador = contador +1
    u = np.random.uniform(0,1)
    Y = np.random.uniform(0,1)
    quo = np.sin(Y)
  return Y*(np.pi),contador
print(amost_rej_med)
contador= [amost_rej_med()[1] for _ in range(100000)]
media = np.mean(contador)
print(np.pi/2)
print(media)
print(1/media)