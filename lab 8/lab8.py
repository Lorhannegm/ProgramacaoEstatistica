# -*- coding: utf-8 -*-
"""lab8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ojGlwZ9srZs_AWE0qGK9HzXIOIaU4vbA

# Exercício 1
"""

# Seja l = u + 1 -> u = l - 1
import numpy as np
import matplotlib.pyplot as plt
n = int(input())


def amostra():
    u = np.random.uniform(0,1)
    x1 = ((np.exp(u+1)+ np.exp(2-u))/2)/n
    return(x1)

def amostra_2():
    u = np.random.uniform(0,1)
    x2 = ((np.exp(u+1))/n)
    return(x2)

amostra_1 = [amostra() for _ in range(10000)]
print(amostra_1)
var_amostra_1 = np.var(amostra_1)
print(var_amostra_1)
amostra2 = [amostra_2() for _ in range(10000)]
print(amostra2)
var_amostra2 = np.var(amostra2)
print(var_amostra2)
#podemos perceber que quando usamos variáveis antiéticas nossa variância diminui de quando usamos só Monte Carlo

plt.hist(amostra_1)
plt.show()

plt.hist(amostra2)
plt.show()

"""# Exercício 2"""



"""

# Exercício 3"""

# X ~ N(1,2) -> Z = (X - 1)/2 ~ N(0,1), X = 2Z + 1
def gerar_bernoulli ( p ):
 u = np.random.uniform( 0 , 1 )
 if  u<= p:
  return 1
 else :
   return 0
def exponencial(lam):
  u = np.random.uniform(0,1)
  x = -np.log(1-u)/lam
  return x

def normal_padrao():
  Y = exponencial(1)
  u = np.random.uniform(0.1)
  B = gerar_bernoulli(0.5)
  while u >= np.exp(-(Y-1)/2):
    Y = exponencial(1)
    u = np.random.uniform(0,1)
  if B == 1:
    return Y
  else:
    return -Y

def normal(mu,sigma2):
  Y = exponencial(1)
  u = np.random.uniform(0.1)
  B = gerar_bernoulli(0.5)
  sigma = np.sqrt(sigma2)
  while u >= np.exp(-(Y-1)/2):
    Y = exponencial(1)
    u = np.random.uniform(0,1)
  if B == 1:
    return (sigma*Y) + mu
  else:
    return (sigma*(-Y)) + mu
n = int(input())

def funcao():
  z = normal_padrao()
  z_novo =((np.exp((-(2*z)**2 +2*z - 1)+ np.exp(-(2*z)**2 -2*z+ 1))/2)/n)
  return(z_novo)

amostra_3 = [funcao() for _ in range(10000)]
print(amostra_3)
var_amostra_3 = np.var(amostra_3)
print(var_amostra_3)

def funcao2():
  j = normal(1,2)
  k = (np.exp((j**2+1)/n))
  return(k)

amostra_4 = [funcao2() for _ in range(10000)]
print(amostra_4)
var_amostra_4 = np.var(amostra_4)
print(var_amostra_4)

plt.hist(amostra_3)
plt.show()

plt.hist(amostra_4)
plt.show()